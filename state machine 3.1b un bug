"""This is a template for State Machine Modules

   A State Machine module is a python file that contains a  `loop` function.
   Similar to how an Arduino program operates, `loop` is called continuously:
   when the function terminates, it is called again.

   The `loop` function should continuously listens to messages generated by:
   - the path detector (concerning the path to follow),
   - the sign detector (concerning road signs detected, if any),
   - the remote command operator (concerning commands to start/stop driving,
     or do specific manoeuvers)
   - and the arduino controller of the physical car (concerning the current
     state; possible sensor readings, ...)

   and decide on how to drive the car correspondingly. See the description of
   the `loop` method below for more details.
"""

import logging
import time
from event import Event
from car import Car


# constants for the different states in which we can be operating
IDLE = 1
STOPPED = 2
MOVING = 3
# You can add other states here


# Setup up the state machine. The following code is called when the state
# machine is loaded for the first time.
logging.info('Template StateMachine has been initialized')

# The next variable is a global variable used to store the state between
# successive calls to loop()
state = IDLE
pathdetector= True # variable d√©finisant si le path detector est actif ou non (selon les maneuvre)
manoeuvre31b = False

def loop():
    '''State machine control loop.
    Like an arduino program, this function is called repeatedly: whenever
    it exits it is called again. Inside the function, call:
    - time.sleep(x) to sleep for x seconds (x can be fractional)
    - Event.poll() to get the next event (output of Path and/or Sign detector,
      status sent by the car, or remote command).
    - Car.send(x,y,u,v) to communicate two integers (x and y) and
      two floats(u,v) to the car. How the car interprets this message depends
      on how you implement the arduino nano. For the simulator, x, and y
      are ignored while u encodes the speed and v the relative angle to turn
      to.
    '''
    global state  # define state to be a global variable
    global pathdetector
    global manoeuvre31b 
    event = Event.poll()
    if event is not None:
        if event.type == Event.CMD and event.val == "GO":
            # A command by the remote computer to start the car
            logging.info("remotely ordered to GO!")
            # TODO: here you would change status, and actuate car if necessary
            state = MOVING
            Car.send(0, 0 ,4 , 0)
            event
            pass
        if event.type == Event.CMD and event.val == "1.1":
            logging.info("maneuvre 1.1")
            pathdetector = False
            state = MOVING
            Car.send(0, 0, 5, 0)
            event
            time.sleep(5)
            event
            Car.send(0, 0, 0, 0)
            state = STOPPED
            pass
        if event.type == Event.CMD and event.val == "1.2":
            logging.info("maneuvre 1.2")
            pathdetector = False
            state = MOVING		
            Car.send(0, 0, 3, 0)
            event
            time.sleep(5)
            event
            Car.send(0, 0, 0, 0)
            state = STOPPED
            pass
        if event.type == Event.CMD and event.val == "1.3":
            logging.info("maneuvre 1.3")
            pathdetector = False
            Car.send(0, 0, 3, 0)
            event
            time.sleep(3)
            state = MOVING
            event
            Car.send(0, 0, 0, 0)
            event  
            time.sleep(2)
            state = STOPPED
            event
            Car.send(0, 0, 3, 0)
            Event.poll()
            time.sleep(2)
            state = MOVING
            event
            Car.send(0, 0, 0, 0)
            state = STOPPED
            pass
        if event.type == Event.CMD and event.val == "2.2":
            logging.info("maneuvre 2.2")
            pathdetector = False
            state = MOVING
            state = MOVING
            Car.send(0, 0, 3, 1.7)
            time.sleep(8)
            Car.send(0, 0, 3, 1.7)
            time.sleep(9.2)
            Car.send(0, 0, 0, 0)
            state = STOPPED
            pass
        if event.type == Event.CMD and event.val == "2.3":
            logging.info("maneuvre 2.3")
            pathdetector = False
            state = MOVING
            Car.send(0, 0, 3, 0)
            time.sleep(1.1)
            Car.send(0, 0, 0, 0)
            state = STOPPED
            Car.send(0, 0, 0, 90)
            state = MOVING
            Car.send(0, 0, 3, 0)
            time.sleep(1.11)
            Car.send(0, 0, 0, 0)
            state = STOPPED
            Car.send(0, 0, 0, 90)
            state = MOVING
            Car.send(0, 0, 3, 0)
            time.sleep(1.12)
            Car.send(0, 0, 0, 0)
            state = STOPPED
            Car.send(0, 0, 0, 90)
            state = MOVING
            Car.send(0, 0, 3, 0)
            time.sleep(1.13)
            Car.send(0, 0, 0, 0)
            state = STOPPED
            pass
        if event.type == Event.CMD and event.val == "3.1b":
            logging.info("maneuvre 3.1b")
            state = MOVING
            manoeuvre31b = True
            pass
        elif event.type == Event.CMD and event.val == "STOP":
            logging.info("remotely ordered to stop")
            # TODO: here you would order to car to stop immediately, and go to
            # stop state
       	    # Note that you can decide to act on  other evant.val value for events
            # of type Event.CMD!
            emergency_stop()
            pass
        elif event.type == Event.PATH and pathdetector :
            # You received the PATH dictionary emitted by the path detector
            # you can access this dictionary in event.val
            # actuate car coresspondingly, change state if relevant
            logging.info(manoeuvre31b)
            handle_path_event(event,manoeuvre31b)
            pass
        elif event.type == Event.SIGN:
            # You received the SIGN dictionary emitted by the sign detector
            # you can access this dictionary in event.val
            # actuate car coresspondingly, change state if relevant
            pass
        elif event.type == Event.CAR:
            # You received a message from the arduino that is operating the car
            # In this case, event.val contains a dictionary with keys x,y,u,v
            # where x and y are ints; u,v, are floats.
            # Act on this message depending on how you implemented the arduino
            # (e.g., is the arduino sending that there is an obstacle in front
            # and you should stop ?)
            logging.info("Received CAR event with x=%d, y=%d, u=%f, v=%f" %
                (event.val['x'], event.val['y'], event.val['u'], event.val['v']))
            pass 
    else:
        # we are in a state that we shouldn't be actuating
        return
def emergency_stop():
    global state
    Car.send(0, 0, 0.0, 0.0)
    event
    state = STOPPED
    pass
def handle_path_event(event,manoeuvre31b):
    global state
    path_dict = event.val
    if state == MOVING:
        heading = path_dict['heading']      
        distance = path_dict['distance']
        angle = path_dict['angle31']
        #actuate_heading(event,heading)
        if distance < 10: 
            state = STOPPED
            Car.send(0, 0 ,0 ,0)
            event
        if manoeuvre31b :
            logging.info(angle)
            Car.send(0, 0, 3, angle)
            event
            Car.send(0, 0, 0, 0)
            event
            time.sleep(200)
    else:
        # we are in a state that we shouldn't be actuating
        return
def handle_path_event(event,manoeuvre31b):
    global state
    path_dict = event.val
    if state == MOVING:
        heading = path_dict['heading']      
        distance = path_dict['distance']
        angle = path_dict['angle31']
        if actuateheading :
            actuate_heading(event,heading)
        if distance < 10: 
            state = STOPPED
            Car.send(0, 0 ,0 ,0)
            event
        if manoeuvre31b :
            logging.info(angle)
            Car.send(0, 0, 1, angle)
            event
            Car.send(0, 0, 0, 0)
            event
            time.sleep(200)
    else:
        # we are in a state that we shouldn't be actuating
        return
def actuate_heading(event, heading):
    if heading < -3 :  # ignore absurd angles
        heading = -1
        Car.send(0, 0, 1, heading)
        #event Car.send(0, 0, 3, 0)
    elif heading > 3 :  # ignore absurd angles
        heading = 1
        Car.send(0, 0, 1, heading)
        #event        Car.send(0, 0, 3, 0) 
