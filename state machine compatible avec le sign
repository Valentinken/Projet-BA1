"""This is a template for State Machine Modules

   A State Machine module is a python file that contains a  `loop` function.
   Similar to how an Arduino program operates, `loop` is called continuously:
   when the function terminates, it is called again.

   The `loop` function should continuously listens to messages generated by:
   - the path detector (concerning the path to follow),
   - the sign detector (concerning road signs detected, if any),
   - the remote command operator (concerning commands to start/stop driving,
     or do specific manoeuvers)
   - and the arduino controller of the physical car (concerning the current
     state; possible sensor readings, ...)

   and decide on how to drive the car correspondingly. See the description of
   the `loop` method below for more details.
"""
from time import time
import logging
import time
from event import Event
from car import Car


# constants for the different states in which we can be operating
IDLE = 1
STOPPED = 2
MOVING = 3
# You can add other states here


# Setup up the state machine. The following code is called when the state
# machine is loaded for the first time.
logging.info('Template StateMachine has been initialized')

# The next variable is a global variable used to store the state between
# successive calls to loop()
st = 0
ga = 0
dr = 0
croisement = 0
state = IDLE
manoeuvre = {'pathdetector' : True, 'manoeuvre3a.1' : False, 'manoeuvre3a.2' : False, 'manoeuvre3b.1' : False, 'manoeuvre3b.2' : False, 'manoeuvre3b.3' : False, 'manoeuvre3b.4' : False, 'manoeuvre3b.5' : False,'manoeuvre3b.7' : False, 'manoeuvre4.1' : False, 'manoeuvre4.2' : False, 'manoeuvre4.3' : False, 'manoeuvre4.4' : False, 'sign' : True} # crée un  dictionnaire globale permettant d'activé (ou non les manoeuvres)
panneau = False
def loop():
    '''State machine control loop.
    Like an arduino program, this function is called repeatedly: whenever
    it exits it is called again. Inside the function, call:
    - time.sleep(x) to sleep for x seconds (x can be fractional)
    - Event.poll() to get the next event (output of Path and/or Sign detector,
      status sent by the car, or remote command).
    - Car.send(x,y,u,v) to communicate two integers (x and y) and
      two floats(u,v) to the car. How the car interprets this message depends
      on how you implement the arduino nano. For the simulator, x, and y
      are ignored while u encodes the speed and v the relative angle to turn
      to.
    '''
    global state  # define state to be a global variable
    global manoeuvre
    global panneau
    global croisement
    event = Event.poll()
    if event is not None:
        if event.type == Event.CMD and event.val == "GO":
            # A command by the remote computer to start the car
            logging.info("remotely ordered to GO!")
            # TODO: here you would change status, and actuate car if necessary
            state = MOVING
            Car.send(0, 0 ,2 , 0)
            event
            pass
        if event.type == Event.CMD and event.val == "1.1":
            logging.info("maneuvre 1.1")
            manoeuvre['pathdetector'] = False
            state = MOVING
            Car.send(0, 0, 5, 0)
            event
            time.sleep(5)
            event
            Car.send(0, 0, 0, 0)
            state = STOPPED
            pass
        if event.type == Event.CMD and event.val == "1.2":
            logging.info("maneuvre 1.2")
            manoeuvre['pathdetector'] = False
            state = MOVING		
            Car.send(0, 0, 3, 0)
            event
            time.sleep(5)
            event
            Car.send(0, 0, 0, 0)
            state = STOPPED
            pass
        if event.type == Event.CMD and event.val == "1.3":
            logging.info("maneuvre 1.3")
            manoeuvre['pathdetector'] = False
            Car.send(0, 0, 3, 0)
            event
            time.sleep(3)
            state = MOVING
            event
            Car.send(0, 0, 0, 0)
            event  
            time.sleep(2)
            state = STOPPED
            event
            Car.send(0, 0, 3, 0)
            Event.poll()
            time.sleep(2)
            state = MOVING
            event
            Car.send(0, 0, 0, 0)
            state = STOPPED
            pass
        if event.type == Event.CMD and event.val == "2.2":
            logging.info("maneuvre 2.2")
            manoeuvre['pathdetector'] = False
            state = MOVING
            Car.send(0, 0, 3, 1.7)
            time.sleep(8)
            Car.send(0, 0, 3, 1.7)
            time.sleep(9.2)
            Car.send(0, 0, 0, 0)
            state = STOPPED
            pass
        if event.type == Event.CMD and event.val == "2.3":
            logging.info("maneuvre 2.3")
            manoeuvre['pathdetector'] = False
            state = MOVING
            Car.send(0, 0, 3, 0)
            time.sleep(1.1)
            Car.send(0, 0, 0, 0)
            state = STOPPED
            Car.send(0, 0, 0, 90)
            state = MOVING
            Car.send(0, 0, 3, 0)
            time.sleep(1.11)
            Car.send(0, 0, 0, 0)
            state = STOPPED
            Car.send(0, 0, 0, 90)
            state = MOVING
            Car.send(0, 0, 3, 0)
            time.sleep(1.12)
            Car.send(0, 0, 0, 0)
            state = STOPPED
            Car.send(0, 0, 0, 90)
            state = MOVING
            Car.send(0, 0, 3, 0)
            time.sleep(1.13)
            Car.send(0, 0, 0, 0)
            state = STOPPED
            pass
        if event.type == Event.CMD and event.val == "3a.1":
            logging.info("maneuvre 3a.1")
            manoeuvre['manoeuvre3b.1'] = True
            manoeuvre['pathdetector'] = False
            pass
        if event.type == Event.CMD and event.val == "3a.2":
            logging.info("maneuvre 3a.2")
            manoeuvre['manoeuvre3a.2'] = True
            manoeuvre['pathdetector'] = False
            pass
        if event.type == Event.CMD and event.val == "3b.1":
            logging.info("maneuvre 3b.1")
            state = MOVING
            manoeuvre['manoeuvre3b.1'] = True
            Car.send(0, 0, 2, 0)
            event
            pass
        if event.type == Event.CMD and event.val == "3b.2":
            logging.info("maneuvre 3b.2")
            state = MOVING
            manoeuvre['manoeuvre3b.2'] = True
            manoeuvre['pathdetector'] = False
            pass
        if event.type == Event.CMD and event.val == "3b.3":
            logging.info("maneuvre 3b.3")
            state = MOVING
            manoeuvre['manoeuvre3b.3'] = True
            Car.send(0, 0, 2, 0)
            event
            pass
        if event.type == Event.CMD and event.val == "3b.4":
            logging.info("maneuvre 3b.4")
            state = MOVING
            manoeuvre['manoeuvre3b.4'] = True
            Car.send(0, 0, 2, 0)
            event
            pass
        if event.type == Event.CMD and event.val == "3b.5":
            logging.info("maneuvre 3b.7")
            state = MOVING
            manoeuvre['manoeuvre3b.5'] = True
            Car.send(0, 0, 2, 0)
            event
            pass
        if event.type == Event.CMD and event.val == "3b.7":
            logging.info("maneuvre 3b.7")
            state = MOVING
            manoeuvre['manoeuvre3b.7'] = True
            Car.send(0, 0, 2, 0)
            event
            pass
        if event.type == Event.CMD and event.val == "4.1":
            logging.info("maneuvre 4.1")
            state = MOVING
            manoeuvre['manoeuvre4.1'] = True
            Car.send(0, 0, 2, 0)
            event
            pass
        if event.type == Event.CMD and event.val == "4.2":
            logging.info("maneuvre 4.2")
            state = MOVING
            manoeuvre['manoeuvre4.2'] = True
            Car.send(0, 0, 2, 0)
            event
            pass
        if event.type == Event.CMD and event.val == "4.3":
            logging.info("maneuvre 4.3")
            state = MOVING
            manoeuvre['manoeuvre4.3'] = True
            Car.send(0, 0, 2, 0)
            event
            pass
        if event.type == Event.CMD and event.val[:2] == "4.4":
            logging.info("maneuvre 4.4")
            state = MOVING
            manoeuvre['manoeuvre4.4'] = True
            croisement = event.val[3]
            Car.send(0, 0, 2, 0)
            event
            pass
        elif event.type == Event.CMD and event.val == "STOP":
            logging.info("remotely ordered to stop")
            # TODO: here you would order to car to stop immediately, and go to
            # stop state
       	    # Note that you can decide to act on  other evant.val value for events
            # of type Event.CMD!
            emergency_stop()
            pass
        elif event.type == Event.PATH and manoeuvre['manoeuvre3b.2'] :
            # You received the PATH dictionary emitted by the path detector
            # you can access this dictionary in event.val
            # actuate car coresspondingly, change state if relevant
            handle_manoeuvre3b2(event)
            pass
        elif event.type == Event.PATH and manoeuvre['pathdetector'] :
            # You received the PATH dictionary emitted by the path detector
            # you can access this dictionary in event.val
            # actuate car coresspondingly, change state if relevant
            handle_path_event(event)
            pass
        elif event.type == Event.SIGN and manoeuvre['sign'] :
            # You received the SIGN dictionary emitted by the sign detector
            # you can access this dictionary in event.val
            # actuate car coresspondingly, change state if relevant
            signdict = event.val
            panneau = signdict["sign"]
            logging.info(panneau)
            signrepertorie(panneau)
            pass
        elif event.type == Event.CAR:
            # You received a message from the arduino that is operating the car
            # In this case, event.val contains a dictionary with keys x,y,u,v
            # where x and y are ints; u,v, are floats.
            # Act on this message depending on how you implemented the arduino
            # (e.g., is the arduino sending that there is an obstacle in front
            # and you should stop ?)
            logging.info("Received CAR event with x=%d, y=%d, u=%f, v=%f" %
                (event.val['x'], event.val['y'], event.val['u'], event.val['v']))
            if event.val['x'] :
                emergency_stop(event)    
            pass 
    else:
        # we are in a state that we shouldn't be actuating
        return
def handle_path_event(event):
    global state
    global manoeuvre
    global panneau
    global croisement
    global st
    global dr
    global ga
    path_dict = event.val
    if state == MOVING :
        heading = path_dict['heading']
        devant = path_dict['devant']           
        distance = path_dict['distance']
        gauche = path_dict['gauche']
        droite = path_dict['droite']
        if manoeuvre['manoeuvre4.4'] and droite :
                None # la fonction heading fait tout le boulot
        if not st and not ga and not dr : # si aucun panneau n'est détécté
            if manoeuvre['manoeuvre3b.1'] :
                None # la fonction heading fait tout le boulot
            elif manoeuvre['manoeuvre3b.3'] :
                if devant and gauche and droite : # detecte un carfour
                    logging.info('condition réspécté')
            elif manoeuvre['manoeuvre3b.4'] :
                if devant and gauche and not droite or devant and not gauche and droite : # detecte un croisement en T
                    logging.info('condition réspécté')
            elif manoeuvre['manoeuvre3b.5'] :
                if not devant and gauche and droite : # detecte un branchement en T
                    logging.info('condition réspécté')
                    heading+= 10000 # demmande à la voiture de tourné fortement à gauche
            elif manoeuvre['manoeuvre3b.7'] :
                if gauche : # tourne a gauche dés qu'il le peut
                    logging.info('condition réspécté')
                    heading+= 10000 # demmande à la voiture de tourné fortement à gauche
            elif droite == 1000000 : #n'arrive jammais (juste pour conservé le code)
                heading-= 10000 # demmande à la voiture de tourné fortement à droite
            else : # fonction pour faire mes test (GO)
                if gauche :
                    heading+= 10000 # demmande à la voiture de tourné fortement à gauche
        elif manoeuvre['manoeuvre3a.1'] :
            Car.send(0, 0, 0, 0)  
            logging.info('panneau stop détécté') 
            manoeuvre['manoeuvre3a.1'] = False 
        elif manoeuvre['manoeuvre4.1'] and (time.time()-st)<1 :
            logging.info("========================================================")
            Car.send(0, 0, 0, 0) 
            event 
            logging.info('panneau stop détécté') 
            time.sleep(3)          
            Car.send(0, 0, 2, 0) 
            event                 
        elif manoeuvre['manoeuvre3a.2'] and st !=0:
            Car.send(0, 0, 0, 0)   
            logging.info('panneau tourner à gauche détécté') 
            manoeuvre['manoeuvre3a.2'] = False
        elif manoeuvre['manoeuvre3a.2'] and dr!=0:
            Car.send(0, 0, 0, 0)   
            logging.info('panneau tourner à droite détécté')   
        elif manoeuvre['manoeuvre4.3'] and gauche and ga !=0 :
            logging.info('panneau tourner à gauche détécté') 
            heading+= 10000 
            manoeuvre['manoeuvre3a.2'] = False
        elif manoeuvre['manoeuvre4.2'] and droite and dr !=0:
            logging.info('panneau tourner à droite détécté') 
            heading -= 10000 
        actuate_heading(event,heading) # enclanche la fonction corrigent la trajectoire de la voiture
    else : # on n'est pas en mouvement
        return
def signdisable(numero) :
    global manoeuvre
    global panneau
    manoeuvre['sign'] = False
    manoeuvre[numero] = False
    panneau = False
    Car.send(0, 0 ,2 ,0)    
    time.sleep(4)
    manoeuvre['sign'] = True
    manoeuvre[numero] = True
    pass
def actuate_heading(event,heading): # Fonction encore en phase de test
    if heading > 9000 : # fait tourné la voiture fortement à gauche
        state = MOVING
        heading = 2.5
        Car.send(0, 0,2, heading)   
        event
    elif heading < -9000 : # fait tourné la voiture fortement à droite
        state = MOVING
        heading = -2.5
        Car.send(0, 0,2, heading)   
        event     
    elif heading < -0.5 : # fait tourné la voiture à droite
        state = MOVING
        heading = -0.5
        Car.send(0, 0,2, heading)   
        event
    elif heading > 0.5 : # fait tourné la voiture à gauche
        state = MOVING
        heading = 0.5
        Car.send(0, 0, 2, heading)
        event
    pass   
def handle_manoeuvre3b2(event) :  
    path_dict = event.val
    global state  
    heading = path_dict['angle31']
    logging.info(angle)
    Car.send(0, 0, 0, angle)
    event
    Car.send(0, 0, 0, 0)
    event 
    time.sleep(200)
    pass
def emergency_stop(event) :
    global state
    global manoeuvre
    Car.send(0, 0, 0, 0)
    state = STOPPED
    event.val = 0
    manoeuvre = {'pathdetector' : False, 'manoeuvre3a.1' : False, 'manoeuvre3a.2' : False, 'manoeuvre3b.1' : False, 'manoeuvre3b.2' : False, 'manoeuvre3b.3' : False, 'manoeuvre3b.4' : False, 'manoeuvre3b.5' : False,'manoeuvre3b.7' : False, 'manoeuvre4.1' : False, 'manoeuvre4.2' : False, 'manoeuvre4.3' : False, 'manoeuvre4.4' : False, 'sign' : False} 

def signrepertorie(panneau) :
    logging.info("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa")        
    global st
    global dr
    global ga
    if panneau == "Stop" and st == 0:
        st = time.time()
        logging.info(time.time()-st)
    elif panneau == "right" and dr == 0:
        dr = time()
    elif panneau == "left" and ga == 0:
        ga = time()
    if time.time()-st > 8 :
        st = 0
    elif time.time()-dr > 5 :
        dr = 0
    elif time.time()-ga > 5 :
        ga = 0
    pass
